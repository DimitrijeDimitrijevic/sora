# SORA MAIL SERVER - CONFIGURATION FILE
# =============================================================================
#
# This is the main configuration file for Sora, a hackable IMAP server built
# with Go and PostgreSQL. This file contains all available configuration
# options with detailed explanations and examples.
#
# IMPORTANT:
# - Copy this file to config.toml and modify the values for your deployment
# - All sections and options are documented with their default values
# - Duration values accept Go duration format: "1h", "30m", "5s", "100ms"
# - Size values accept common suffixes: "1gb", "100mb", "5kb"
#
# CONFIG VALIDATION:
# - Unknown keys will log warnings but are ignored (helps detect typos)
# - Duplicate keys will log warnings and use first occurrence
# - Syntax errors (e.g., "f" instead of "false") will fail with helpful hints
# - Run './sora --config config.toml' to validate your configuration

# LOGGING CONFIGURATION
# =============================================================================
# Structured logging configuration using Go's standard slog library.

[logging]
output = "stderr"         # Log destination: "stderr", "stdout", "syslog", or "/path/to/file.log"
format = "console"        # Log format: "json" for structured JSON logs, "console" for human-readable text
level = "info"            # Log level: "debug", "info", "warn", "error"


# DATABASE CONFIGURATION
# =============================================================================
# PostgreSQL database connection settings with read/write split support.
# Sora requires PostgreSQL with the pg_trgm extension for full-text search.

[database]
debug = false                   # Enable SQL query logging. Useful for debugging, but impacts performance.
query_timeout = "30s"           # Default timeout for all database queries (e.g., "30s", "1m").
search_timeout = "1m"           # Specific timeout for complex search queries (e.g., "60s", "2m").
write_timeout = "15s"           # Timeout for write operations (INSERT, UPDATE, DELETE).
migration_timeout = "2m"        # Timeout for auto-migrations at startup. When multiple instances start simultaneously,
                                # one will run migrations while others wait. If timeout is reached, the instance will
                                # verify migrations are complete before continuing. Default: "2m" (2 minutes).

# WRITE DATABASE CONFIGURATION
# =============================================================================
# Primary database endpoint for all write operations (INSERT, UPDATE, DELETE).

[database.write]
hosts = ["localhost"]         # Database server hosts. Can be ["host:port"] or multiple for failover.
port = 5432                   # Database port. Alternative to including it in hosts.
user = "postgres"             # Database username for authentication.
password = ""                 # Database user password. Leave empty for no password.
name = "sora_mail_db"         # Database name to connect to.
tls = false                   # Enable TLS/SSL for database connection. Recommended for remote connections.

# --- WRITE DATABASE CONNECTION POOL SETTINGS ---
# Fine-tune write database connection management for optimal performance.
max_conns = 50                  # Maximum connections in the write pool. Should be < PostgreSQL max_connections.
min_conns = 5                   # Minimum connections maintained in write pool (kept alive always).
max_conn_lifetime = "1h"        # Maximum lifetime before write connection refresh (prevents stale connections).
max_conn_idle_time = "30m"      # Maximum idle time before closing excess write connections (above min_conns).
query_timeout = "30s"           # Per-endpoint timeout for individual database queries (e.g., "30s").


# READ DATABASE CONFIGURATION
# =============================================================================
# Read replica database endpoint(s) for SELECT operations. Can specify multiple
# hosts for load balancing across read replicas. If not configured, read
# operations will use the write database connection pool.

[database.read]
hosts = ["localhost"]         # Database server hosts for read operations. Can specify multiple for load balancing.
port = 5432                   # Database port for read operations.
user = "postgres"             # Database username for read operations.
password = ""                 # Database user password for read operations.
name = "sora_mail_db"         # Database name for read operations (typically same as write).
tls = false                   # Enable TLS/SSL for read database connections.

# --- READ DATABASE CONNECTION POOL SETTINGS ---
# Fine-tune read database connection management for optimal performance.
max_conns = 100                 # Maximum connections in the read pool. Can be higher than write pool.
min_conns = 10                  # Minimum connections maintained in read pool.
max_conn_lifetime = "1h"        # Maximum lifetime before read connection refresh.
max_conn_idle_time = "30m"      # Maximum idle time before closing excess read connections.
query_timeout = "30s"           # Per-endpoint timeout for individual database queries (e.g., "30s").


# S3-COMPATIBLE OBJECT STORAGE CONFIGURATION  
# =============================================================================
# Sora stores message bodies in S3-compatible object storage for scalability
# and durability. Message metadata remains in PostgreSQL for fast access.

[s3]
endpoint = "s3.amazonaws.com"           # S3-compatible storage endpoint URL (e.g., "s3.amazonaws.com", "minio.example.com:9000").
disable_tls = false                     # Disable TLS for S3 endpoint. Useful for local MinIO setups.
access_key = "YOUR_S3_ACCESS_KEY_HERE"  # S3 access key ID for authentication.
secret_key = "YOUR_S3_SECRET_KEY_HERE"  # S3 secret access key for authentication.
bucket = "your-sora-mail-bucket"        # S3 bucket name for storing message bodies. Must be globally unique.
debug = false                           # Enable detailed S3 request/response tracing. Impacts performance.

# --- CLIENT-SIDE ENCRYPTION SETTINGS ---
# Encrypt message bodies before uploading to S3 for additional security
encrypt = false                                                                    # Enable client-side encryption. Messages are encrypted before S3 upload.
encryption_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" # 32-byte master encryption key (64 hex chars). CRITICAL: Store securely! Gen: openssl rand -hex 32


# TLS/SSL CONFIGURATION
# =============================================================================
# TWO WAYS TO CONFIGURE TLS:
#
# OPTION A: Global TLS Manager (this section)
# - Centralized certificate management for ALL servers
# - Supports Let's Encrypt automatic certificates with auto-renewal
# - Supports file-based certificates
# - When enabled, ALL servers with tls=true will use certificates from here
# - Servers do NOT need tls_cert_file/tls_key_file when global TLS is enabled
#
# OPTION B: Per-Server TLS (in each [[server]] section)
# - Individual certificate files per server (tls_cert_file, tls_key_file)
# - More flexible but requires manual certificate management
# - Use this if you need different certificates per protocol/server
# - Global TLS manager must be DISABLED (enabled = false) to use per-server TLS
#
# IMPORTANT: You cannot mix both approaches!
# - If [tls] enabled = true → all servers use global TLS, ignore per-server tls_cert_file/tls_key_file
# - If [tls] enabled = false → each server needs its own tls_cert_file/tls_key_file
#
# RECOMMENDATION: Use global TLS with Let's Encrypt for automatic certificate management

[tls]
enabled = false                                 # Enable global TLS management (default: false)
provider = "file"                               # TLS provider: "file" or "letsencrypt" (default: "file")

# --- OPTION 1: FILE-BASED CERTIFICATES (provider = "file") ---
# Use this for static certificates (purchased SSL, self-signed, or existing certs)
# Both cert_file and key_file are REQUIRED when provider = "file"
cert_file = "/path/to/cert.pem"                 # Full path to PEM-encoded certificate file
key_file = "/path/to/key.pem"                   # Full path to PEM-encoded private key file

# EXAMPLE USAGE (Global TLS with file-based certificates):
# [tls]
# enabled = true
# provider = "file"
# cert_file = "/etc/ssl/certs/mail.example.com.crt"
# key_file = "/etc/ssl/private/mail.example.com.key"
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true                    # Enable TLS
# # tls_cert_file NOT needed - uses global [tls] cert
# # tls_key_file NOT needed - uses global [tls] cert

# --- OPTION 2: LET'S ENCRYPT AUTOMATIC CERTIFICATES (provider = "letsencrypt") ---
# Use this for automatic, free TLS certificates with auto-renewal
# REQUIREMENTS:
# - Domains must have DNS A records pointing to this server's public IP
# - Port 80 must be accessible from the internet (for HTTP-01 challenge validation)
# - S3 bucket for certificate storage (allows sharing across multiple instances)
# - AWS credentials or IAM role with S3 access
[tls.letsencrypt]
email = "admin@example.com"                     # REQUIRED: Email for Let's Encrypt account (used for expiration notices and account recovery)
domains = ["mail.example.com"]                  # REQUIRED: List of domains for certificate (supports multiple: ["mail.example.com", "imap.example.com", "smtp.example.com"])
default_domain = ""                             # OPTIONAL: Default domain to use when client doesn't provide SNI (Server Name Indication). If not specified, uses first domain from list.
                                                # Use this to handle legacy clients that don't support SNI.
storage_provider = "s3"                         # Certificate storage backend (currently only "s3" is supported)

# OPTIONAL: Customize certificate renewal window (default: 30 days before expiry)
# renew_before = "720h"                         # Renew certificates 720 hours (30 days) before expiration (format: "Xh", "Xd" not supported, use hours)

# OPTIONAL: Local filesystem fallback for S3 outages (enabled by default)
# enable_fallback = true                        # Enable local filesystem fallback when S3 is unavailable (default: true)
# fallback_dir = "/var/lib/sora/certs"          # Local directory to cache certificates when S3 is unavailable (default: "/var/lib/sora/certs")
#
# IMPORTANT: If the fallback directory cannot be created (e.g., permission denied),
# Sora will automatically disable fallback and use S3-only mode with a warning.

# S3 storage configuration for Let's Encrypt certificates
# Certificates are stored in S3 to enable sharing across multiple Sora instances
[tls.letsencrypt.s3]
bucket = "sora-tls-certificates"                # S3 bucket name for certificate storage (bucket must exist before starting Sora)
endpoint = "s3.amazonaws.com"                   # S3-compatible storage endpoint (default: "s3.amazonaws.com" for AWS, or "minio.example.com:9000" for MinIO)
disable_tls = false                             # Disable TLS for S3 endpoint (useful for local MinIO setups)
debug = false                                   # Enable detailed S3 request/response tracing (impacts performance)
# access_key_id = ""                            # AWS/S3 access key ID (optional - uses IAM credentials chain if omitted)
# secret_access_key = ""                        # AWS/S3 secret access key (optional - uses IAM credentials chain if omitted)
# This prevents server crashes due to filesystem permission issues.
#
# When to disable fallback (enable_fallback = false):
# - You prefer hard failure when S3 is down (fail-fast approach)
# - You don't want local disk dependencies
# - You're running in a container with ephemeral storage
# - You have strict compliance requirements about certificate storage locations

# EXAMPLE USAGE (Global TLS with Let's Encrypt):
# [tls]
# enabled = true
# provider = "letsencrypt"
# # cert_file and key_file are not needed for Let's Encrypt
#
# [tls.letsencrypt]
# email = "admin@example.com"
# domains = ["mail.example.com", "imap.example.com"]
# storage_provider = "s3"
#
# [tls.letsencrypt.s3]
# bucket = "sora-tls-certificates"
# region = "us-east-1"
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true                    # Enable TLS
# # tls_cert_file NOT needed - uses global [tls] cert
# # tls_key_file NOT needed - uses global [tls] cert

# --- OPTION 3: PER-SERVER TLS (Alternative to Global TLS) ---
# Use this if you need different certificates for different protocols/servers
# IMPORTANT: Global [tls] must be DISABLED (enabled = false) to use this approach
#
# EXAMPLE USAGE (Per-server TLS with different certificates):
# [tls]
# enabled = false               # MUST be false for per-server TLS
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true
# tls_cert_file = "/etc/ssl/certs/imap.example.com.crt"
# tls_key_file = "/etc/ssl/private/imap.example.com.key"
#
# [[server]]
# type = "pop3"
# name = "main-pop3"
# addr = ":995"
# tls = true
# tls_cert_file = "/etc/ssl/certs/pop3.example.com.crt"  # Different cert!
# tls_key_file = "/etc/ssl/private/pop3.example.com.key"

# SETUP STEPS FOR LET'S ENCRYPT:
# 1. Create S3 bucket:
#    aws s3 mb s3://sora-tls-certificates --region us-east-1
# 2. Verify DNS A records:
#    dig +short mail.example.com  # Should return your server's public IP
# 3. Ensure port 80 is open:
#    Sora will automatically start an HTTP-01 challenge server on port 80
# 4. Set provider = "letsencrypt" and enabled = true
# 5. Start Sora - certificates will be issued on first HTTPS request
#
# FEATURES:
# - Automatic certificate issuance (30-60 seconds on first request)
# - Automatic renewal (certificates renewed 30 days before expiration by default, configurable via renew_before)
# - Hot reload (new certificates automatically loaded on next TLS handshake - no restart needed)
# - Multi-instance support (multiple Sora instances share certificates via S3)
# - Zero-downtime renewal (renewals happen in background during TLS handshakes)
# - Server-side encryption (certificates encrypted at rest with AES256)
# - File fallback (local filesystem cache when S3 is unavailable - automatic recovery)
# - Cost: ~$0.001/month for S3 storage
#
# LIMITATIONS:
# - Let's Encrypt rate limits: 50 certificates per domain per week
# - Requires port 80 for HTTP-01 challenges (cannot be changed)
# - Only supports HTTP-01 challenge (no DNS-01 for wildcard certificates yet)


# CLUSTER CONFIGURATION
# =============================================================================
# Distributed coordination using gossip protocol (HashiCorp memberlist)
# for leader election and cluster membership management.
#
# USE CASE: When running multiple Sora instances with Let's Encrypt TLS,
# cluster mode ensures only ONE node requests certificates from Let's Encrypt
# at a time, preventing rate limit issues and duplicate certificate requests.
#
# ARCHITECTURE:
# - Uses gossip protocol for peer discovery and failure detection
# - Leader election based on lexicographically smallest node ID (deterministic)
# - Only the leader node can request new TLS certificates
# - All nodes can read certificates from S3 (shared storage)
# - Automatic failover when leader goes down

[cluster]
enabled = false                                 # Enable cluster mode (default: false)
bind_addr = "0.0.0.0"                           # Gossip protocol bind address (default: "0.0.0.0")
bind_port = 7946                                # Gossip protocol port (default: 7946)
node_id = ""                                    # Unique node ID (default: hostname)
peers = []                                      # Initial seed nodes for cluster discovery (e.g., ["node-1.example.com", "node-2.example.com"])
                                                # IMPORTANT: Do NOT include this node's own node_id in the peers list!
                                                # Only list OTHER nodes in the cluster. Self-references will be filtered out
                                                # automatically and a warning will be logged.
secret_key = ""                                 # Cluster encryption key: base64-encoded 32-byte key (REQUIRED for production)
                                                # Generate with: openssl rand -base64 32

# --- CLUSTER-WIDE AUTH RATE LIMITING ---
# Synchronize authentication rate limiting across cluster nodes via gossip protocol.
# When enabled, failed authentication attempts on one node immediately block the IP
# on all other nodes, providing cluster-wide brute-force protection.
[cluster.rate_limit_sync]
enabled = true                                  # Enable cluster-wide rate limiting (default: true if cluster enabled)
sync_blocks = true                              # Synchronize IP blocks across nodes (default: true)
sync_failure_counts = true                      # Synchronize progressive delay failure counts (default: true)

# --- CLUSTER-WIDE SERVER AFFINITY ---
# Synchronize user-to-backend affinity (sticky sessions) across cluster nodes via gossip.
# When enabled, users are consistently routed to the same backend server across all proxy nodes
# for better cache locality and connection reuse. Affinity automatically updates when backends fail.
# NOTE: Affinity is ONLY for non-prelookup users. Prelookup routes are always authoritative.
[cluster.affinity]
enabled = false                                 # Enable cluster-wide server affinity (default: false)
ttl = "24h"                                     # How long affinity persists (default: "24h")
cleanup_interval = "1h"                         # How often to clean up expired affinities (default: "1h")

# EXAMPLE USAGE (Multi-instance deployment):
# [cluster]
# enabled = true
# bind_addr = "0.0.0.0"
# bind_port = 7946
# node_id = "sora-1"                            # Or leave empty to use hostname
# peers = ["sora-2.example.com", "sora-3.example.com"]  # Only need 1-2 seed nodes, gossip discovers others
# secret_key = "YOUR_BASE64_ENCODED_32_BYTE_SECRET_KEY_HERE"

# SETUP STEPS:
# 1. Generate cluster secret key:
#    openssl rand -base64 32
# 2. Configure same secret_key on all nodes (CRITICAL: must match across cluster)
# 3. Set unique node_id for each node (or use default hostname)
# 4. Specify 1-2 peer nodes for initial discovery
# 5. Start all nodes - they will discover each other via gossip
# 6. Verify cluster membership: check logs for "Cluster manager initialized"
#
# FEATURES:
# - Automatic leader election (lexicographically smallest node ID)
# - Peer discovery via gossip protocol (memberlist)
# - Failure detection and automatic failover
# - Encrypted communication (AES-256 when secret_key is set)
# - Zero single point of failure
#
# INTEGRATION WITH TLS:
# When cluster mode is enabled with Let's Encrypt:
# - Only the cluster leader requests new certificates from Let's Encrypt
# - Non-leader nodes read certificates from S3 (shared storage)
# - Prevents Let's Encrypt rate limiting (50 certs/domain/week)
# - Prevents duplicate certificate requests
# - Automatic leadership handoff when leader fails
#
# PORTS:
# - bind_port (7946): Gossip protocol communication (TCP + UDP)
# - Ensure this port is accessible between all cluster nodes
#
# SECURITY:
# - ALWAYS use secret_key in production for encrypted gossip communication
# - Use firewall rules to restrict bind_port access to cluster nodes only
# - Rotate secret_key periodically (requires cluster restart)
#
# MONITORING:
# - Log messages show cluster membership changes
# - Log messages show leader election results
# - Example: "Cluster leader changed: node-1 -> node-2 (this node is leader: false)"


# LOCAL CACHE CONFIGURATION
# =============================================================================
# Local filesystem cache for frequently accessed message bodies, reducing
# S3 API calls and improving performance for recently accessed messages.

[local_cache]
path = "/tmp/sora/cache"      # Filesystem path for cache storage. Must be writable. Fast storage (SSD) recommended.
capacity = "1gb"              # Maximum total cache size (e.g., "100mb", "1gb"). LRU eviction when exceeded.
max_object_size = "5mb"       # Maximum size for individual cached objects. Prevents large messages from dominating cache.
metrics_interval = "5m"       # How often cache hit/miss ratios are stored in the database.
metrics_retention = "30d"     # How long to retain cache metrics in the database.
purge_interval = "12h"        # How often to run cache cleanup (capacity enforcement, stale entry removal).
orphan_cleanup_age = "30d"    # Minimum age before orphaned cache entries (for deleted DB messages) are removed.

# --- CACHE WARMUP ---
# Preload recent messages when users reconnect to improve performance.
enable_warmup = true          # Enable cache warmup on user login.
warmup_message_count = 50     # Number of recent messages to preload per mailbox.
warmup_mailboxes = ["INBOX"]  # Mailboxes to warm up. Most clients check INBOX first. e.g., ["INBOX", "Sent"].
warmup_async = true           # true: warmup happens in background (fast login). false: blocks login.
warmup_timeout = "5m"         # Maximum time allowed for a cache warmup operation.
warmup_interval = "24h"       # Minimum time between warmups for the same user. Prevents warmup on every connection.


# S3 UPLOADER CONFIGURATION
# =============================================================================
# Background worker that handles asynchronous uploads of message bodies
# to S3 storage after messages are initially stored locally.

[uploader]
path = "/tmp/sora/uploads"    # Filesystem path for staging uploads (temporary storage before S3).
batch_size = 20               # Number of messages batched together per upload operation.
concurrency = 10              # Number of concurrent upload workers.
max_attempts = 5              # Maximum retry attempts for failed uploads.
retry_interval = "30s"        # Initial delay between retry attempts (exponential backoff is applied).


# CLEANUP PROCESS CONFIGURATION
# =============================================================================
# Background worker that manages message lifecycle and removes old/deleted
# messages according to configured retention policies.

[cleanup]
grace_period = "14d"          # Recovery window for accidentally deleted messages before permanent removal.
wake_interval = "1h"          # How often the cleanup worker runs.
max_age_restriction = ""      # Max message age before auto-expungement. Empty = no limit. e.g., "90d", "365d".
fts_retention = "730d"        # How long to keep full-text search content in DB. Older messages lose searchability.
auth_attempts_retention = "7d"  # How long to retain authentication attempt logs in the database.
health_status_retention = "30d" # How long to retain health status history in the database.
stale_connections_retention = "30m" # How long before inactive connections are removed. Catches ungraceful disconnects.


# AUTHENTICATION CACHE CONFIGURATION
# =============================================================================
# In-memory authentication result caching to reduce database load.
# Particularly useful for:
# - Parallel client connections (mail clients often open 3-5+ IMAP connections)
# - Mitigating DoS attacks from non-existent account lookups
# - Reducing latency for repeated authentication attempts
#
# Security note: Cached credentials are verified on every use. Only successful
# credential lookups are cached temporarily to avoid repeated DB queries.

[auth_cache]
enabled = false              # Enable authentication result caching. Default: false (disabled).
positive_ttl = "30s"         # How long to cache successful authentications. Short TTL recommended for security.
negative_ttl = "5m"          # How long to cache failed authentication attempts (user not found, invalid password).
                            # Longer TTL helps mitigate brute force attacks against non-existent accounts.
max_size = 10000            # Maximum number of cached authentication results. LRU eviction when exceeded.
cleanup_interval = "5m"     # How often to remove expired cache entries and update metrics.


# METADATA LIMITS CONFIGURATION
# =============================================================================
# IMAP METADATA extension (RFC 5464) limits to prevent storage abuse.
# These limits apply per-account and help protect against excessive metadata usage.
#
# NOTE: "server-level" (SETMETADATA "") means account-level metadata (global, not mailbox-specific).
#       "mailbox-level" (SETMETADATA "INBOX") means per-mailbox metadata.

[metadata]
max_entry_size = 65536         # Maximum size per metadata entry (64KB). Prevents huge single values.
max_entries_per_mailbox = 1000 # Maximum number of metadata entries per mailbox (mailbox-level).
max_entries_per_server = 1000  # Maximum number of account-level metadata entries (server-level).
max_total_size = 1048576       # Maximum total metadata size per account (1MB). Overall quota protection.


# SHARED MAILBOXES CONFIGURATION
# =============================================================================
# Enable shared mailboxes for collaboration between users on the same domain.
# Uses IMAP namespace extension (RFC 2342) for proper client support.
# Implements Access Control Lists (RFC 4314) for fine-grained permissions.

[shared_mailboxes]
enabled = false                  # Enable shared mailbox functionality (default: false)
namespace_prefix = "Shared/"     # IMAP namespace prefix for shared mailboxes (e.g., "Shared/" or "#shared/")
allow_user_create = false        # Allow regular users to create shared mailboxes (false = admin-only)
default_rights = "lrswipkxtea"   # Default ACL rights for shared mailbox creators (full rights by default)
                                # Rights: l=lookup, r=read, s=seen, w=write, i=insert, p=post, k=create, x=delete, t=delete-msg, e=expunge, a=admin

# IMPORTANT NOTES:
# - Shared mailboxes are restricted to users within the same domain for security
# - Creators automatically receive the default_rights on mailboxes they create
# - Additional users must be granted access via IMAP ACL commands or admin API
# - The NAMESPACE command will advertise the shared namespace when enabled


# GLOBAL SERVERS CONFIGURATION
# =============================================================================
# Global settings that apply to all protocol servers.

[servers]
# Note: Debug logging is now configured per-server using the 'debug' option on individual servers

# --- TRUSTED NETWORKS ---
# Networks trusted for proxy parameter forwarding (XCLIENT, ID commands, etc.)
# These networks can forward client information through proxy protocols
trusted_networks = ["127.0.0.0/8", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "::1/128"]


# DYNAMIC SERVER CONFIGURATION
# =============================================================================
# Sora now uses a dynamic server configuration system that allows you to define
# multiple servers of any type with individual configurations. Each server is
# defined as a [[server]] section with a unique name and configuration.
#
# Server Types:
# - imap: IMAP4rev1 server for email access
# - lmtp: Local Mail Transfer Protocol for mail delivery
# - pop3: POP3 server for email download
# - managesieve: ManageSieve server for SIEVE script management
# - imap_proxy: IMAP proxy server for load balancing
# - pop3_proxy: POP3 proxy server for load balancing
# - managesieve_proxy: ManageSieve proxy server for load balancing
# - lmtp_proxy: LMTP proxy server for load balancing
# - metrics: Prometheus metrics HTTP endpoint
# - http_admin_api: REST API server for administrative operations
#
# IMPORTANT: You must configure at least one server for Sora to start.

# IMAP SERVER EXAMPLE
# =============================================================================
# Internet Message Access Protocol - primary protocol for email access
# Supports IMAP4rev1 with IDLE extension for real-time notifications.

[[server]]
type = "imap"
name = "main-imap"            # Unique server name for identification
addr = ":143"                 # Listen address and port. Use :993 for IMAPS.
debug = false                 # Enable debug logging for this IMAP server

# --- CONNECTION LIMITING AND MEMORY MANAGEMENT ---
max_connections = 1000        # Maximum concurrent IMAP connections across all clients.
max_connections_per_ip = 10   # Max connections per client IP. Set to 0 if behind a load balancer.

# --- IMAP-SPECIFIC CONFIGURATION ---
append_limit = "25mb"         # Maximum message size for IMAP APPEND. Empty = no limit.

# --- MASTER USER AUTHENTICATION ---
master_username = ""          # Master username for administrative IMAP access (e.g., for proxies).
master_password = ""          # Password for master_username.
master_sasl_username = ""     # Alternative master username for SASL authentication.
master_sasl_password = ""     # Password for master_sasl_username.

# --- TLS/SSL CONFIGURATION ---
# TWO OPTIONS:
# 1. Use global TLS manager (see [tls] section above) - recommended for Let's Encrypt
#    Set tls=true and OMIT tls_cert_file/tls_key_file (they will be ignored)
# 2. Use per-server certificates (only if global [tls] enabled=false)
#    Set tls=true AND provide tls_cert_file/tls_key_file below
tls = false                               # Enable TLS for IMAP (IMAPS). Typically on port 993.
# tls_cert_file = "/path/to/your/imap.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/imap.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false                        # Verify client certificates (mutual TLS). Usually false.

# --- PROXY PROTOCOL CONFIGURATION ---
# Enable if this server is behind a load balancer or reverse proxy
proxy_protocol = false            # Enable PROXY protocol support (HAProxy, nginx, etc.)
proxy_protocol_timeout = "5s"     # Timeout for reading PROXY protocol headers

# --- GLOBAL CAPABILITY CONFIGURATION ---
# Disable specific IMAP capabilities for ALL clients connecting to this server.
# Disabled capabilities are not announced in CAPABILITY responses and cannot be used.
#
# This is different from client_filters which apply based on client identity.
# Use this when you want to disable capabilities for ALL clients on this server.
#
# Common capabilities that can be disabled:
# - ESEARCH: Extended search (RFC 4731)
# - CONDSTORE: Conditional STORE (RFC 7162)
# - IDLE: Push notifications (RFC 2177)
# - MOVE: Efficient message moving (RFC 6851)
# - COMPRESS: DEFLATE compression (RFC 4978)
# - SORT/ESORT: Server-side sorting
#
# disabled_caps = ["ESEARCH", "CONDSTORE", "IDLE"]  # Example: disable these capabilities globally
#
# NOTE: Do not disable core capabilities like IMAP4rev1, STARTTLS, or AUTH=PLAIN
# as this will break basic IMAP functionality.

# --- CLIENT CAPABILITY FILTERS ---
# Disable specific IMAP capabilities for problematic clients based on their ID or TLS fingerprint
# This helps work around client bugs while maintaining full functionality for well-behaved clients
# Note: Filtered capabilities are removed from CAPABILITY responses and command handlers reject their use

# Match by client name (from IMAP ID command)
# [[server.client_filters]]
# client_name = "com\\.apple\\.email\\.maild"  # iOS Apple Mail (regex pattern)
# client_version = ".*"                        # Any version
# disable_caps = ["CONDSTORE"]                 # Capabilities to disable
# reason = "iOS Apple Mail has CONDSTORE implementation issues"

# Match by client name and version
# [[server.client_filters]]
# client_name = "Microsoft Outlook"            # Outlook for Windows/Mac
# client_version = "16\\..*"                   # Only version 16.x
# disable_caps = ["IDLE", "CONDSTORE"]         # Multiple capabilities
# reason = "Outlook 16.x has connection issues with IDLE and CONDSTORE"

# Match by JA4 TLS fingerprint (requires TLS or PROXY protocol with JA4 TLV)
# Useful for filtering before client sends ID command, or when client doesn't send ID
# [[server.client_filters]]
# ja4_fingerprints = ["^t13d1516h2_8daaf6152771_.*"]  # Single JA4 pattern (as array)
# disable_caps = ["ESEARCH", "IDLE"]
# reason = "Client with this TLS fingerprint has issues"

# Match by multiple JA4 fingerprints (one client may have different fingerprints)
# [[server.client_filters]]
# client_name = "com\\.apple\\.email\\.maild"
# client_version = ".*"
# ja4_fingerprints = [
#   "^t13d411100_6be44479b708_.*",  # iOS with one network config
#   "^t13d2014ip_a09f3c656075_.*",  # iOS with IPv6
#   "^t13i201200_a09f3c656075_.*",  # iOS with different cipher preference
# ]
# disable_caps = ["ESEARCH", "CONDSTORE", "IDLE"]
# reason = "iOS Apple Mail has implementation issues (multiple fingerprints)"

# Matching logic:
# - If ja4_fingerprints specified: matches if ANY pattern matches (OR)
# - If client_name/version specified: matches if BOTH name AND version match (AND)
# - Between ja4_fingerprints and client_name/version: matches if EITHER criteria is met (OR)

# --- AUTHENTICATION RATE LIMITING ---
[server.auth_rate_limit]
enabled = false                   # Enable authentication rate limiting.
max_attempts_per_ip = 10          # Max failed auth attempts per IP address.
max_attempts_per_username = 5     # Max failed auth attempts per username (across all IPs).
ip_window_duration = "15m"        # Time window for IP-based rate limiting.
username_window_duration = "30m"  # Time window for username-based rate limiting.
cleanup_interval = "5m"           # How often to clean up expired rate limiting data.
fast_block_threshold = 10         # Failed attempts before immediate IP blocking.
fast_block_duration = "5m"        # Duration of the fast IP block.
delay_start_threshold = 2         # Failed attempts before applying authentication delays.
initial_delay = "2s"              # Initial authentication delay after threshold is reached.
max_delay = "30s"                 # Maximum authentication delay.
delay_multiplier = 2.0            # Multiplier for progressive delay (exponential backoff).
cache_cleanup_interval = "1m"     # How often to clean up expired in-memory cache entries.
db_sync_interval = "30s"          # How often to sync batched auth attempts to the database.
max_pending_batch = 100           # Max pending auth attempts before forcing a DB sync.
db_error_threshold = "1m"         # Time to wait before retrying DB operations after an error.

# --- RESOURCE LIMITS ---
[server.limits]
# Search rate limiting - prevent DoS attacks via excessive search queries
search_rate_limit_per_min = 0     # Maximum searches per minute per user (0 = disabled).
search_rate_limit_window = "1m"   # Time window for search rate limiting (e.g., "1m", "2m").

# Session memory limiting - prevent memory exhaustion attacks (IMAP FETCH/SEARCH commands)
session_memory_limit = "100mb"    # Maximum memory per session (e.g., "50mb", "200mb", 0 = unlimited).

# --- SESSION TIMEOUTS ---
# Multi-layered timeout protection against various DoS attacks:
# 1. Idle timeout (command_timeout): Closes connections with no activity
# 2. Absolute session timeout: Maximum total session duration regardless of activity
# 3. Throughput enforcement (min_bytes_per_minute): Closes connections transferring data too slowly
[server.timeouts]
command_timeout = "5m"             # Maximum idle time (default: 5 minutes, e.g., "30s", "5m").
absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes, e.g., "15m", "1h").
min_bytes_per_minute = 1024        # Minimum throughput to prevent slowloris attacks (default: 1024 bytes/min, 0 = use default).


# LMTP SERVER EXAMPLE
# =============================================================================
# Local Mail Transfer Protocol - handles incoming mail delivery from MTAs

[[server]]
type = "lmtp"
name = "main-lmtp"
addr = ":24"
debug = true                  # Enable debug logging for LMTP server
max_connections = 500
max_connections_per_ip = 5
external_relay = ""           # External SMTP relay for mail forwarding (optional).
tls = false
tls_use_starttls = false      # Use STARTTLS for opportunistic encryption.
# tls_cert_file = "/path/to/your/lmtp.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/lmtp.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false
proxy_protocol = false        # Enable PROXY protocol support for LMTP
proxy_protocol_timeout = "5s"

# --- MESSAGE SIZE LIMITING ---
# Maximum size for incoming LMTP messages to prevent memory exhaustion attacks
max_message_size = "50mb"     # Maximum message size (default: 50MB, 0 = unlimited)


# POP3 SERVER EXAMPLE
# =============================================================================
# Post Office Protocol version 3 - legacy protocol for downloading email

[[server]]
type = "pop3"
name = "main-pop3"
addr = ":110"                 # Use :995 for POP3S.
max_connections = 500
max_connections_per_ip = 5
master_sasl_username = ""
master_sasl_password = ""
tls = false
# tls_cert_file = "/path/to/your/pop3.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/pop3.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false
proxy_protocol = false        # Enable PROXY protocol support for POP3
proxy_protocol_timeout = "5s"

# --- AUTHENTICATION RATE LIMITING ---
# Same configuration available as shown in IMAP example above
# [server.auth_rate_limit]
# enabled = false

# --- SESSION MEMORY LIMITING ---
# Per-session memory limit to prevent memory exhaustion attacks (POP3 RETR/TOP commands)
session_memory_limit = "100mb"    # Maximum memory per session (e.g., "50mb", "200mb", 0 = unlimited).

# --- COMMAND TIMEOUT AND SLOWLORIS PROTECTION ---
# Multi-layered timeout protection against various DoS attacks:
# 1. Idle timeout: Closes connections with no activity
# 2. Absolute session timeout: Maximum total session duration regardless of activity
# 3. Throughput enforcement: Closes connections transferring data too slowly
command_timeout = "2m"             # Maximum idle time (default: 2 minutes, e.g., "30s", "5m").
absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes, e.g., "15m", "1h").
min_bytes_per_minute = 1024        # Minimum throughput to prevent slowloris attacks (default: 1024 bytes/min, 0 = use default).


# MANAGESIEVE SERVER EXAMPLE
# =============================================================================
# ManageSieve protocol for managing SIEVE mail filtering scripts

[[server]]
type = "managesieve"
name = "main-managesieve"
addr = ":4190"
max_connections = 200
max_connections_per_ip = 3
max_script_size = "16kb"      # Maximum size for a SIEVE script.
supported_extensions = ["fileinto", "vacation", "envelope", "regex"]  # Supported SIEVE extensions. Available: envelope, fileinto, redirect, encoded-character, imap4flags, variables, relational, vacation, copy, regex
insecure_auth = false                            # Allow plaintext auth. SECURITY: Should be false in production.
master_sasl_username = ""
master_sasl_password = ""
tls = false
tls_use_starttls = false
tls_cert_file = "/path/to/your/managesieve.crt"
tls_key_file = "/path/to/your/managesieve.key"
tls_verify = true
proxy_protocol = false        # Enable PROXY protocol support for ManageSieve
proxy_protocol_timeout = "5s"

# --- AUTHENTICATION RATE LIMITING ---
# Same configuration available as shown in IMAP example above
# [server.auth_rate_limit]
# enabled = false

# --- COMMAND TIMEOUT AND SLOWLORIS PROTECTION ---
# Multi-layered timeout protection against various DoS attacks:
# 1. Idle timeout: Closes connections with no activity
# 2. Absolute session timeout: Maximum total session duration regardless of activity
# 3. Throughput enforcement: Closes connections transferring data too slowly
command_timeout = "3m"             # Maximum idle time (default: 3 minutes, e.g., "30s", "5m").
absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes, e.g., "15m", "1h").
min_bytes_per_minute = 1024        # Minimum throughput to prevent slowloris attacks (default: 1024 bytes/min, 0 = use default).


# IMAP PROXY EXAMPLE
# =============================================================================
# Proxy IMAP connections across multiple backend servers with load balancing

[[server]]
type = "imap_proxy"
name = "imap-proxy-1"
addr = ":1143"                # Proxy listen address. Must be different from backend IMAP port.
remote_addrs = ["backend1.example.com:143", "backend2.example.com:143", "backend3.example.com:143"]
max_connections = 2000
max_connections_per_ip = 50
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = true

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_id_command = false         # Send IMAP ID command to backends

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
session_timeout = "30m"
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- COMMAND TIMEOUT AND SLOWLORIS PROTECTION ---
# Multi-layered timeout protection against various DoS attacks:
# 1. Idle timeout: Closes connections with no activity
# 2. Absolute session timeout: Maximum total session duration regardless of activity
# 3. Throughput enforcement: Closes connections transferring data too slowly
command_timeout = "5m"             # Maximum idle time (default: 5 minutes, e.g., "30s", "5m").
absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes, e.g., "15m", "1h").
min_bytes_per_minute = 1024        # Minimum throughput to prevent slowloris attacks (default: 1024 bytes/min, 0 = use default).

# --- AUTHENTICATION RATE LIMITING ---
# Same configuration available as shown in IMAP example above
# [server.auth_rate_limit]
# enabled = false

# --- HTTP-BASED USER ROUTING (PRELOOKUP) ---
# Advanced feature for routing users to specific backend servers via HTTP API.
#
# The prelookup service is called via HTTP GET with email interpolation.
# The URL can contain $email placeholder which is replaced with the URL-encoded email address.
#
# Example URLs:
#   "http://localhost:8080/lookup?email=$email" → GET /lookup?email=user@domain.com
#   "http://localhost:8080/user/$email/info"    → GET /user/user@domain.com/info
#
# The HTTP endpoint should return a JSON response with the following fields:
#
# REQUIRED FIELDS:
# - address: Email address for backend impersonation (string)
# - password_hash: Password hash to verify authentication (string)
# - server: Backend server address - can be IP/hostname:port OR just IP/hostname (string)
#   * If port is included: "192.168.1.10:143" or "backend.example.com:993"
#   * If port is omitted: "192.168.1.10" or "backend.example.com"
#     → Port from remote_port config will be appended (default: 143)
# - account_id: Account ID for tracking/metrics (integer, must be > 0)
#
# Example JSON Response (with port):
# {
#   "address": "user@domain.com",
#   "password_hash": "$2a$12$abcdef...",
#   "server": "backend1.example.com:143",
#   "account_id": 12345
# }
#
# Example JSON Response (without port - uses remote_port):
# {
#   "address": "user@domain.com",
#   "password_hash": "$2a$12$abcdef...",
#   "server": "192.168.1.10",
#   "account_id": 12345
# }
#
# BEHAVIOR:
# - HTTP GET request is made for each authentication attempt
# - Circuit breaker protects against service failures (60% failure rate triggers open state)
# - Password formats: bcrypt ($2a$...), SSHA512 ({SSHA512}...), SHA512 ({SHA512}...), BLF-CRYPT ($2b$...)
# - If HTTP endpoint returns 404 or 5xx → falls back to default routing (if fallback_to_default=true)
# - If HTTP endpoint returns 200 with data but auth fails → connection REJECTED (no fallback)
# - Server addresses normalized: missing ports use remote_port default (e.g., 143 for IMAP)
# - Timeout for HTTP requests is configurable (default: 5s)
#
# ALIAS RESOLUTION:
# The "address" field in the response is used for backend impersonation. This enables alias resolution:
# - Request: user logs in with "alias@domain.com"
# - Response: {"address": "realuser@domain.com", ...}
# - Proxy connects to backend and authenticates as "realuser@domain.com"
#
[server.prelookup]
enabled = false                             # Enable/disable HTTP-based user routing.
url = "http://localhost:8080/lookup?email=$email"  # HTTP endpoint URL with $email placeholder (required if enabled)
                                            # The $email placeholder is replaced with the URL-encoded email address
                                            # Examples:
                                            #   "http://localhost:8080/lookup?email=$email" → query parameter
                                            #   "http://localhost:8080/user/$email/lookup" → path parameter
                                            #   "http://localhost:8080/api/v1/auth?user=$email&format=json" → custom format
timeout = "5s"                              # HTTP request timeout (default: 5s)
# auth_token = "your-secret-token"          # Bearer token for HTTP authentication (optional)
                                            # If set, sends "Authorization: Bearer <token>" header with requests
                                            # Use this to secure your prelookup endpoint

fallback_to_default = true            # If prelookup initialization fails (e.g., endpoint unreachable), continue without prelookup
                                      # using default round-robin routing. If false, proxy fails to start on prelookup errors.
                                      # NOTE: This only applies to initialization failures, not per-user lookup failures.
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
                                      # NOTE: Only supported for LMTP and ManageSieve proxies.
                                      #       IMAP and POP3 proxies use implicit TLS and ignore this setting.
remote_tls_verify = true              # Verify backend TLS certificates
# remote_port = 143                   # Default port to append if server address doesn't include port (default: 143)
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_id_command = false         # Send IMAP ID command to backends (IMAP only)

  # --- PRELOOKUP CACHING ---
  # In-memory caching of HTTP prelookup results for improved performance.
  # Significantly reduces HTTP requests by caching authentication results.
  #
  # CACHE BEHAVIOR:
  # - Positive results (successful auth): Cached with longer TTL
  # - Negative results (failed auth, user not found): Cached with shorter TTL
  # - Cache key: Combination of email and password hash
  # - Thread-safe with read/write locks
  # - Background cleanup of expired entries
  # - LRU-style eviction when max size exceeded
  #
  # BENEFITS:
  # - Reduced latency: Sub-millisecond cache lookups vs HTTP roundtrip
  # - Reduced load: Fewer requests to prelookup HTTP endpoint
  # - DDoS protection: Negative caching prevents repeated failed auth attempts
  # - Configurable: Separate TTLs for positive/negative results
  #
  # EXAMPLE SCENARIOS:
  # - User authenticates successfully → cached for 5 minutes
  # - Same user authenticates again within 5 minutes → instant cache hit
  # - Attacker tries wrong password → cached as failed for 1 minute
  # - Attacker retries same wrong password → instant rejection from cache
  #
  # [server.prelookup.cache]
  # enabled = false                 # Enable in-memory caching of prelookup results (default: false)
  # positive_ttl = "5m"             # TTL for successful authentication (default: 5m)
                                    # How long to cache valid credentials
                                    # Longer TTL = fewer HTTP requests, but password changes take longer to take effect
  # negative_ttl = "1m"             # TTL for failed auth or user not found (default: 1m)
                                    # Shorter TTL avoids caching temporary issues (e.g., typos, transient failures)
                                    # Provides DDoS protection while allowing quick recovery
  # max_size = 10000                # Maximum number of cached entries (default: 10000)
                                    # When exceeded, oldest entries (by expiration time) are evicted
                                    # Memory usage: ~1-2 KB per entry, so 10000 entries ≈ 10-20 MB
  # cleanup_interval = "1m"         # How often to scan and remove expired entries (default: 1m)
                                    # More frequent = lower memory usage, slightly higher CPU
                                    # Less frequent = higher memory usage, lower CPU

  # --- CIRCUIT BREAKER FOR PRELOOKUP ENDPOINT ---
  # Protects the system from cascading failures when the HTTP prelookup endpoint becomes unavailable.
  # When the endpoint starts failing (timeouts, 5xx errors, network issues), the circuit breaker
  # automatically "opens" to prevent further requests and allow the service to recover.
  #
  # CIRCUIT BREAKER STATES:
  # - CLOSED: Normal operation, all requests go through
  # - OPEN: Endpoint is failing, all requests rejected immediately (respects fallback_to_default)
  # - HALF-OPEN: Testing recovery, limited requests allowed to check if endpoint recovered
  #
  # RECOVERY PROCESS:
  # 1. Circuit opens after failure_ratio threshold reached (default: 60% of last 3 requests fail)
  # 2. Waits for timeout period (default: 30s)
  # 3. Transitions to half-open and allows max_requests concurrent test requests (default: 3)
  # 4. If tests succeed → circuit closes and normal operation resumes
  # 5. If tests fail → circuit re-opens and waits another timeout period
  #
  # IMPORTANT: Only server errors (5xx), timeouts, and network failures trigger the circuit breaker.
  # Valid responses like 404 (user not found) do NOT count as failures.
  #
  # PRODUCTION RECOMMENDATIONS:
  # - timeout: 60s-300s (longer allows more time for service recovery)
  # - max_requests: 5-10 (more requests = better confidence in recovery)
  # - min_requests: 5-10 (avoids opening circuit on brief hiccups)
  # - failure_ratio: 0.6-0.8 (60-80% failure rate before opening)
  #
  # [server.prelookup.circuit_breaker]
  # max_requests = 3                # Maximum concurrent requests in half-open state (default: 3)
                                    # Higher values = more confidence that service recovered before closing circuit
                                    # Lower values = faster recovery but may close prematurely
  # timeout = "30s"                 # Time to wait before transitioning from open to half-open (default: 30s)
                                    # How long to wait before testing if the service recovered
                                    # Production: Consider 60s-300s to give services time to recover
  # interval = "0s"                 # Time before resetting failure counts in closed state (default: 0s = never reset)
                                    # Set to non-zero to allow "forgetting" old failures
                                    # Example: "60s" = after 60s of no requests, reset failure counters
  # failure_ratio = 0.6             # Failure ratio threshold to open circuit (0.0-1.0, default: 0.6 = 60%)
                                    # Circuit opens when this percentage of recent requests fail
                                    # Production: Consider 0.7-0.8 for less sensitive triggering
  # min_requests = 3                # Minimum requests before evaluating failure ratio (default: 3)
                                    # Prevents opening circuit on very few requests
                                    # IMPORTANT: Should be ≤ max_requests to avoid getting stuck
                                    # Production: Consider 5-10 for more stable thresholds

  # --- HTTP TRANSPORT CONFIGURATION ---
  # Connection pooling settings for the HTTP client used to query the prelookup endpoint.
  # Proper connection pooling enables parallel authentication requests while reusing connections.
  #
  # TRANSPORT BEHAVIOR:
  # - Multiple concurrent authentication requests reuse pooled HTTP connections
  # - Idle connections are kept alive to avoid TCP handshake overhead
  # - Unlimited concurrent connections per host (max_conns_per_host=0) for high throughput
  #
  # PERFORMANCE IMPACT:
  # - Higher max_idle_conns = more connections kept alive = faster subsequent requests
  # - max_conns_per_host=0 (unlimited) = no bottleneck for concurrent auth requests
  # - Longer idle_conn_timeout = fewer reconnects = better performance under load
  #
  # EXAMPLE SCENARIOS:
  # - 100 concurrent user logins → reuses up to 100 idle connections from pool
  # - Low traffic → connections automatically closed after idle_conn_timeout
  # - High traffic → connections stay warm and reused immediately
  #
  # [server.prelookup.transport]
  # max_idle_conns = 100            # Maximum idle connections across all hosts (default: 100)
                                    # Total number of connections kept alive in the pool
                                    # Higher = more connections reused, less overhead
  # max_idle_conns_per_host = 100   # Maximum idle connections per prelookup host (default: 100)
                                    # For single prelookup endpoint, should match max_idle_conns
                                    # For multiple endpoints, distributes pool across hosts
  # max_conns_per_host = 0          # Maximum total connections per host, 0=unlimited (default: 0)
                                    # Set to 0 (unlimited) for best parallel performance
                                    # Only limit if prelookup endpoint has connection restrictions
  # idle_conn_timeout = "90s"       # How long idle connections stay open (default: "90s")
                                    # Longer = better for sustained traffic, more memory
                                    # Shorter = less memory, more reconnects under load

# --- MASTER TOKEN / ALIAS RESOLUTION ---
# The HTTP endpoint can implement master token authentication or alias resolution.
# The proxy simply passes the full email address to the endpoint and verifies the returned password hash.
#
# Example: Master Token Authentication
# - Client logs in with: email="user@domain.com@MASTERTOKEN", password="anything"
# - HTTP GET request: /lookup?email=user@domain.com@MASTERTOKEN
# - HTTP endpoint splits the email, validates the token, and returns:
#   {
#     "address": "user@domain.com",
#     "password_hash": "<hash of MASTERTOKEN>",
#     "server": "backend1:143",
#     "account_id": 123
#   }
# - Proxy verifies "anything" against the returned hash
# - Proxy connects to backend as "user@domain.com" (from "address" field)
#
# Example: Alias Resolution
# - Client logs in with: email="alias@domain.com", password="userpass"
# - HTTP GET request: /lookup?email=alias@domain.com
# - HTTP endpoint resolves alias and returns:
#   {
#     "address": "realuser@domain.com",
#     "password_hash": "<hash of userpass>",
#     "server": "backend1:143",
#     "account_id": 456
#   }
# - Proxy verifies "userpass" against the returned hash
# - Proxy connects to backend as "realuser@domain.com" (from "address" field)
#
# The "address" field in the HTTP response determines which user the proxy authenticates as on the backend.
# All logic for token splitting, validation, alias resolution, etc. is handled by your HTTP endpoint.
#
# See test_prelookup_server.go for a working example implementation.


# POP3 PROXY EXAMPLE
# =============================================================================
# Proxy POP3 connections across multiple backend servers with load balancing

[[server]]
type = "pop3_proxy"
name = "pop3-proxy-1"
addr = ":1110"                # Proxy listen address. Must be different from backend POP3 port.
remote_addrs = ["backend1.example.com:110", "backend2.example.com:110"]
max_connections = 1000
max_connections_per_ip = 20
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = true

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_xclient = false            # Send XCLIENT command to backends for forwarding client info

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
session_timeout = "10m"
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- COMMAND TIMEOUT AND SLOWLORIS PROTECTION ---
command_timeout = "5m"
absolute_session_timeout = "30m"
min_bytes_per_minute = 1024

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# MANAGESIEVE PROXY EXAMPLE
# =============================================================================
# Proxy ManageSieve connections across multiple backend servers

[[server]]
type = "managesieve_proxy"
name = "managesieve-proxy-1"
addr = ":14190"               # Proxy listen address. Must be different from backend ManageSieve port.
remote_addrs = ["backend1.example.com:4190", "backend2.example.com:4190"]
max_connections = 500
max_connections_per_ip = 10
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_use_starttls = false              # Use STARTTLS on listening port (client connections)
tls_cert_file = ""
tls_key_file = ""
tls_verify = true

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
session_timeout = "15m"
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- COMMAND TIMEOUT AND SLOWLORIS PROTECTION ---
command_timeout = "5m"
absolute_session_timeout = "30m"
min_bytes_per_minute = 1024

# --- SIEVE EXTENSIONS ---
# Builtin extensions are always advertised: fileinto, reject, envelope, encoded-character,
# subaddress, comparator-i;ascii-numeric, relational, imap4flags, copy, include, variables,
# body, enotify, environment, mailbox, date, index, ihave, duplicate, mime, foreverypart, extracttext
#
# Add additional extensions here (e.g., vacation, regex, spamtest, virustest)
supported_extensions = ["vacation", "regex"]

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# LMTP PROXY EXAMPLE
# =============================================================================
# Proxy LMTP connections across multiple backend servers for load balancing

[[server]]
type = "lmtp_proxy"
name = "lmtp-proxy-1"
addr = ":124"                 # Proxy listen address. Must be different from backend LMTP port.
remote_addrs = ["backend1.example.com:24", "backend2.example.com:24"]
max_connections = 1000
max_connections_per_ip = 0    # Typically no per-IP limits for LMTP (trusted sources)

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_use_starttls = false              # Use STARTTLS on listening port (client connections)
tls_cert_file = ""
tls_key_file = ""
tls_verify = true

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_xclient = false            # Send XCLIENT command to backends for forwarding client info

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
session_timeout = "5m"
max_message_size = "50mb"
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# METRICS SERVER EXAMPLE
# =============================================================================
# Prometheus metrics endpoint for monitoring Sora performance

[[server]]
type = "metrics"
name = "prometheus-metrics"
addr = ":9090"
path = "/metrics"             # HTTP endpoint path for metrics.
enable_domain_metrics = true
enable_user_metrics = false  # CAUTION: high cardinality, for small deployments only.
user_metrics_threshold = 1000
max_tracked_users = 1000
hash_usernames = true


# HTTP ADMIN API SERVER EXAMPLE
# =============================================================================
# REST API server for administrative operations (accounts, health, connections, etc.)
# Base URL: /admin/*

[[server]]
type = "http_admin_api"
name = "admin-api"
addr = ":8080"
api_key = "your-secret-api-key-here"  # REQUIRED for API access.
allowed_hosts = []            # Empty = all hosts (not recommended for production).
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = false
proxy_protocol = false        # Enable PROXY protocol support for HTTP API
proxy_protocol_timeout = "5s"


# HTTP USER API SERVER EXAMPLE
# =============================================================================
# REST API server for user mailbox access via HTTP (alternative to IMAP/POP3)
# Provides stateless JWT-based authentication for web and mobile clients
# Base URL: /user/*

[[server]]
type = "http_user_api"
name = "user-api"
addr = ":8081"
jwt_secret = "your-secret-jwt-signing-key-here"  # REQUIRED: Secret key for signing JWT tokens. KEEP SECRET!
token_duration = "24h"        # JWT token validity duration (e.g., "24h", "7d", "12h").
token_issuer = "sora-mail-api" # JWT issuer field (optional, for token validation).
allowed_origins = ["*"]       # CORS allowed origins for web clients. Use specific origins in production: ["https://mail.example.com"]
allowed_hosts = []            # IP addresses allowed to access API. Empty = all hosts.
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = false


# USER API PROXY SERVER EXAMPLE
# =============================================================================
# HTTP reverse proxy for User API - routes requests to backend User API servers
# Authenticates JWT tokens on the proxy and forwards trusted requests to backends
# Supports user-based routing with consistent hashing for affinity
# Use for horizontal scaling of User API across multiple backend servers

#[[server]]
#type = "user_api_proxy"
#name = "user-api-proxy"
#addr = ":8082"                      # Frontend proxy listening address
#remote_addrs = ["backend1:8081", "backend2:8081", "backend3:8081"]  # Backend User API servers
#remote_port = 8081                  # Default backend port if not specified in remote_addrs
#jwt_secret = "your-secret-jwt-signing-key-here"  # REQUIRED: Same JWT secret as backend servers
#max_connections = 10000             # Maximum total concurrent connections (0 = unlimited)
#max_connections_per_ip = 100        # Maximum connections per client IP (0 = unlimited)
#connect_timeout = "10s"             # Timeout for establishing backend connections
#enable_affinity = true              # Enable user-to-backend affinity (sticky routing via consistent hashing)
#tls = false                         # Enable TLS on frontend proxy listener
#tls_cert_file = ""
#tls_key_file = ""
#tls_verify = false
#remote_tls = false                  # Use HTTPS for backend connections
#remote_tls_verify = true            # Verify backend TLS certificates

# IMPORTANT: Backend User API servers should configure allowed_hosts to trust this proxy
# Backend configuration example:
# [[server]]
# type = "http_user_api"
# allowed_hosts = ["10.0.0.0/8"]  # Trust requests from proxy network


# CONNECTION TRACKING CONFIGURATION
# =============================================================================
# Monitor and log active connections across all servers for operational visibility.

[servers.connection_tracking]
enabled = true                    # Enable connection tracking across all protocols.
update_interval = "15s"           # How often to update connection statistics in the database.
termination_poll_interval = "30s" # How often to check for connections marked for termination.
batch_updates = true              # Batch multiple connection updates together for efficiency.
persist_to_db = true              # Store connection tracking information in the database.
operation_timeout = "10s"         # Timeout for individual register/unregister operations. Increase if seeing timeout errors during high load. (default: "10s")
batch_flush_timeout = "45s"       # Timeout for batch flush operations. Increase if seeing batch timeout errors during high load. (default: "45s")
